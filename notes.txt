database -> database.js -> db_manager.js -> queue_manager.js -> queue_route.js -> router.js -> app.js


database
- database.js:
  Establishes the connection between the application and database by requiring postGres which is an interface to connect both sides.
  To establish a connection with the database, information about the database needs to be specified -> done so programatically inside
  the commons.js file by extracting constants from the .env file.
  There are 2 methods of establishing a connection with the database, using pool or client, in this case, we will be using pool, require
  pool inside database.js after installing postgres. Also, require the commons.js file which will be used to specify the information about 
  the database in order to establish a connection with the database
  
- init.sql:
  contains sql commands to create the database and tables

managers
- db_manager.js:
  after you have settled database.js and commons.js which is responsible for establishing a connection 
  with the database, you can now establish methods to interact with the database


- queue_manager.js:
  promise chained from db_manager.js and returns a json object w/ the result from the .then() in db_manager.js

routes
- queue_route.js:
  contains the endpoints. request from client is received here, mf in endpoints get run and calls enqueue function gets run and the resolve
  result which the promise returns is returned back to the endpoint, .then to handle success and .catch to handle error

tests/http
- enqueue-dequeue.test.http:

app.js:
- require express and http, export them

commons.js:
Since these values are constants (unchanging throughout the app's lifecycle), let us create them in a `commons` file. 
Create a file `commons.js` in the root directory and enter the following values:
Note that we are still referencing data from the environment, thus we need to load the values in the `
.env` file into the environment. We will use the `dotenv` npm package to assist us with loading environment
variable. require dotenv inside common.js

docker-compose.yml: 
Tells docker to put the database/init.sql file into the countainer .The 
docker image will then execute this file during the initialisation of
the database, hence creating the database and table.

.env:
environment file which contains all the information about the database

errors.js:

router.js:

www.js:

test.js:

queue_tab:
the table to be created with the attributes


commands:

docker-compose up:
to start the database or to create the database and tables if they 
have yet to be created

node ./www: 
to start the backend server ready to receive request from the client

notes:
front-end:
enqueue-dequeue.test.http

back-end:
www.js

database:
docker stores the init.sql file in one of the docker's container's directories, database is created when docker image runs the init.sql file